'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

var useIsoLayoutEffect = typeof window === 'undefined' ? react.useEffect : react.useLayoutEffect;
function create(createState) {
  var state;
  var subscribers = [];
  var subscriberCount = 0;

  var setState = function setState(partial) {
    var partialState = typeof partial === 'function' ? partial(state) : partial;

    if (partialState !== state) {
      state = Object.assign({}, state, partialState); // Reset subscriberCount because we will be removing holes from the
      // subscribers array and changing the length which should be the same as
      // subscriberCount.

      subscriberCount = 0; // Create a dense array by removing holes from the subscribers array.
      // Holes are not iterated by Array.prototype.filter.

      subscribers = subscribers.filter(function (subscriber) {
        subscriber.index = subscriberCount++;
        return true;
      }); // Call all subscribers only after the subscribers array has been changed
      // to a dense array. Subscriber callbacks cannot be called above in
      // subscribers.filter because the callbacks can cause a synchronous
      // increment of subscriberCount if not batched.

      subscribers.forEach(function (subscriber) {
        return subscriber.callback();
      });
    }
  };

  var getState = function getState() {
    return state;
  };

  var getSubscriber = function getSubscriber(listener, selector, equalityFn) {
    if (selector === void 0) {
      selector = getState;
    }

    if (equalityFn === void 0) {
      equalityFn = Object.is;
    }

    return {
      callback: function callback() {},
      currentSlice: selector(state),
      equalityFn: equalityFn,
      errored: false,
      index: subscriberCount++,
      listener: listener,
      selector: selector
    };
  };

  var subscribe = function subscribe(subscriber) {
    subscriber.callback = function () {
      // Selector or equality function could throw but we don't want to stop
      // the listener from being called.
      // https://github.com/react-spring/zustand/pull/37
      try {
        var newStateSlice = subscriber.selector(state);

        if (!subscriber.equalityFn(subscriber.currentSlice, newStateSlice)) {
          subscriber.listener(subscriber.currentSlice = newStateSlice);
        }
      } catch (error) {
        subscriber.errored = true;
        subscriber.listener(null, error);
      }
    }; // subscriber.index is set during the render phase in order to store the
    // subscibers in a top-down order. The subscribers array will become a
    // sparse array when an index is skipped (due to an interrupted render) or
    // a component unmounts and the subscriber is deleted. It's converted back
    // to a dense array in setState.


    subscribers[subscriber.index] = subscriber; // Delete creates a hole and preserves the array length. If we used
    // Array.prototype.splice, subscribers with a greater subscriber.index
    // would no longer match their actual index in subscribers.

    return function () {
      return delete subscribers[subscriber.index];
    };
  };

  var apiSubscribe = function apiSubscribe(listener, selector, equalityFn) {
    return subscribe(getSubscriber(listener, selector, equalityFn));
  };

  var destroy = function destroy() {
    return subscribers = [];
  };

  var useStore = function useStore(selector, equalityFn) {
    if (selector === void 0) {
      selector = getState;
    }

    if (equalityFn === void 0) {
      equalityFn = Object.is;
    }

    var forceUpdate = react.useReducer(function (c) {
      return c + 1;
    }, 0)[1];
    var subscriberRef = react.useRef();

    if (!subscriberRef.current) {
      subscriberRef.current = getSubscriber(forceUpdate, selector, equalityFn);
    }

    var subscriber = subscriberRef.current;
    var newStateSlice;
    var hasNewStateSlice = false; // The selector or equalityFn need to be called during the render phase if
    // they change. We also want legitimate errors to be visible so we re-run
    // them if they errored in the subscriber.

    if (subscriber.selector !== selector || subscriber.equalityFn !== equalityFn || subscriber.errored) {
      // Using local variables to avoid mutations in the render phase.
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(subscriber.currentSlice, newStateSlice);
    } // Syncing changes in useEffect.


    useIsoLayoutEffect(function () {
      if (hasNewStateSlice) {
        subscriber.currentSlice = newStateSlice;
      }

      subscriber.selector = selector;
      subscriber.equalityFn = equalityFn;
      subscriber.errored = false;
    });
    useIsoLayoutEffect(function () {
      return subscribe(subscriber);
    }, []);
    return hasNewStateSlice ? newStateSlice : subscriber.currentSlice;
  };

  var api = {
    setState: setState,
    getState: getState,
    subscribe: apiSubscribe,
    destroy: destroy
  };
  state = createState(setState, getState, api);
  return [useStore, api];
}

exports.create = create;
exports.default = create;
