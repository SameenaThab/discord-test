{"ast":null,"code":"import { useReducer, useRef, useEffect, useLayoutEffect } from 'react';\nvar useIsoLayoutEffect = typeof window === 'undefined' ? useEffect : useLayoutEffect;\n\nfunction create(createState) {\n  var state;\n  var subscribers = [];\n  var subscriberCount = 0;\n\n  var setState = function setState(partial) {\n    var partialState = typeof partial === 'function' ? partial(state) : partial;\n\n    if (partialState !== state) {\n      state = Object.assign({}, state, partialState); // Reset subscriberCount because we will be removing holes from the\n      // subscribers array and changing the length which should be the same as\n      // subscriberCount.\n\n      subscriberCount = 0; // Create a dense array by removing holes from the subscribers array.\n      // Holes are not iterated by Array.prototype.filter.\n\n      subscribers = subscribers.filter(function (subscriber) {\n        subscriber.index = subscriberCount++;\n        return true;\n      }); // Call all subscribers only after the subscribers array has been changed\n      // to a dense array. Subscriber callbacks cannot be called above in\n      // subscribers.filter because the callbacks can cause a synchronous\n      // increment of subscriberCount if not batched.\n\n      subscribers.forEach(function (subscriber) {\n        return subscriber.callback();\n      });\n    }\n  };\n\n  var getState = function getState() {\n    return state;\n  };\n\n  var getSubscriber = function getSubscriber(listener) {\n    var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getState;\n    var equalityFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Object.is;\n    return {\n      callback: function callback() {},\n      currentSlice: selector(state),\n      equalityFn: equalityFn,\n      errored: false,\n      index: subscriberCount++,\n      listener: listener,\n      selector: selector\n    };\n  };\n\n  var subscribe = function subscribe(subscriber) {\n    subscriber.callback = function () {\n      // Selector or equality function could throw but we don't want to stop\n      // the listener from being called.\n      // https://github.com/react-spring/zustand/pull/37\n      try {\n        var newStateSlice = subscriber.selector(state);\n\n        if (!subscriber.equalityFn(subscriber.currentSlice, newStateSlice)) {\n          subscriber.listener(subscriber.currentSlice = newStateSlice);\n        }\n      } catch (error) {\n        subscriber.errored = true;\n        subscriber.listener(null, error);\n      }\n    }; // subscriber.index is set during the render phase in order to store the\n    // subscibers in a top-down order. The subscribers array will become a\n    // sparse array when an index is skipped (due to an interrupted render) or\n    // a component unmounts and the subscriber is deleted. It's converted back\n    // to a dense array in setState.\n\n\n    subscribers[subscriber.index] = subscriber; // Delete creates a hole and preserves the array length. If we used\n    // Array.prototype.splice, subscribers with a greater subscriber.index\n    // would no longer match their actual index in subscribers.\n\n    return function () {\n      return delete subscribers[subscriber.index];\n    };\n  };\n\n  var apiSubscribe = function apiSubscribe(listener, selector, equalityFn) {\n    return subscribe(getSubscriber(listener, selector, equalityFn));\n  };\n\n  var destroy = function destroy() {\n    return subscribers = [];\n  };\n\n  var useStore = function useStore() {\n    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getState;\n    var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.is;\n    var forceUpdate = useReducer(function (c) {\n      return c + 1;\n    }, 0)[1];\n    var subscriberRef = useRef();\n\n    if (!subscriberRef.current) {\n      subscriberRef.current = getSubscriber(forceUpdate, selector, equalityFn);\n    }\n\n    var subscriber = subscriberRef.current;\n    var newStateSlice;\n    var hasNewStateSlice = false; // The selector or equalityFn need to be called during the render phase if\n    // they change. We also want legitimate errors to be visible so we re-run\n    // them if they errored in the subscriber.\n\n    if (subscriber.selector !== selector || subscriber.equalityFn !== equalityFn || subscriber.errored) {\n      // Using local variables to avoid mutations in the render phase.\n      newStateSlice = selector(state);\n      hasNewStateSlice = !equalityFn(subscriber.currentSlice, newStateSlice);\n    } // Syncing changes in useEffect.\n\n\n    useIsoLayoutEffect(function () {\n      if (hasNewStateSlice) {\n        subscriber.currentSlice = newStateSlice;\n      }\n\n      subscriber.selector = selector;\n      subscriber.equalityFn = equalityFn;\n      subscriber.errored = false;\n    });\n    useIsoLayoutEffect(function () {\n      return subscribe(subscriber);\n    }, []);\n    return hasNewStateSlice ? newStateSlice : subscriber.currentSlice;\n  };\n\n  var api = {\n    setState: setState,\n    getState: getState,\n    subscribe: apiSubscribe,\n    destroy: destroy\n  };\n  state = createState(setState, getState, api);\n  return [useStore, api];\n}\n\nexport default create;\nexport { create };","map":null,"metadata":{},"sourceType":"module"}